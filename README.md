1. type -t cd
   builtin
cd встроенная команда, котороя выполняет действие самостоятельно не вызывая отдельный исполняемый файл. 

2.  grep <some_string> <some_file> -с

3.  pstree -p
    systemd

4.  ls -l test 2>/dev/tty6

5.  cat test.txt
    cat <test.txt >test_out.txt
    cat test_out.txt

6.  У меня все tty, не могу перейти в pty,чтобы проверить. Ctrl + alt + F запускает только tty 
    теоретически получится, если использовать перенаправленный вывод

7.  bash 5>&1 - Создает промежуточный новый дескриптор 5 
    echo netology > /proc/$$/fd/5 - выведет в дескриптор "5", который был пернеаправлен в stdout

8.  5>&2 2>&1 1>&5

9.  Выведет переменные среды
    env и printenv

10. /proc/<PID>/cmdline этот файл только для чтения содержит полный путь до исполняемого файла процесса
    /proc/[pid]/exe  В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, до файла запущенного для процесса

11. grep sse /proc/cpuinfo
    я так понимаю sse4_1, sse4_2

12. При подключении vagrant ssh у меня не создается pty. Когда ввожу tty  получаю /dev/tty
По умолчанию при выполнении команды на удаленной машине с использованием ssh для удаленного сеанса не выделяется TTY. Это позволяет передавать двоичные данные. 
Однако, когда вы запускаете ssh без удаленной команды, он выделяет TTY, потому что вы, скорее всего, будете запускать сеанс оболочки. 
Если вам нужна оболочка, используйте вместо этого ssh -t, что приведет к принудительному выделению TTY во время удаленного выполнения.

13. В начале выдовал ошибку, что команды не существует.
	после установки 
	sudo apt install reptyr
	reptyr 1122
        выдал ошибку и отсылает в файд 10-patrace.conf
	установил kernel.yama.ptrace_scope = 0 и тогда процесс был перехвачен

14.  tee в считывает стандартный ввод и записывает его одновременно в стандартный вывод и в один или несколько подготовленных файлов 
     Команда получает вывод из stdin, перенаправленный через pipe от stdout команды echo. Запись в файл возможна так как запущено от sudo
	

